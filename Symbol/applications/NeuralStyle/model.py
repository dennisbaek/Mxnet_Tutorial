import mxnet as mximport mxnet.ndarray as ndfrom VGG19 import *import mxnet.symbol as symfrom tqdm import *import numpy as npimport matplotlib.pyplot as pltimport DataPreprocessing as dpdef Artistic_Image(noise_image,image_size):    image = noise_image.reshape((-1,)+image_size)    r,g,b = nd.split(image ,axis=0, num_outputs=3)    #Denormalization by JG    r= nd.multiply(r,0.229)+0.485    g= nd.multiply(g,0.224)+0.456    b= nd.multiply(b,0.225)+0.406    image=nd.concat(r,g,b,dim=0)    '''    matplotlib supports float32 and uint8 data types. For grayscale, matplotlib supports only float32.     If your array data does not meet one of these descriptions, you need to rescale it.    '''    image = nd.transpose(image, axes=(1, 2, 0))    image = nd.clip(image , a_min=0 , a_max=1)    image = nd.multiply(image,255)    image = nd.clip(image, a_min=0, a_max=255).astype('uint8')    plt.imshow(image.asnumpy())    plt.savefig("Artistic Image.png", dpi=200)    #plt.show()def NeuralStyle(epoch =None, show_period=None, learning_rate=None, image_size=None,                      content_image=None , style_image=None, content_a=None, style_b=None, initial_noise_image=None, ctx=None):    #1. Data Preprocessing and noise data    content_image, style_image, noise_image =dp.data_preprocessing(content_image = content_image, style_image = style_image, image_size=image_size ,ctx=ctx)    #initializing noise image below values    if initial_noise_image=="content_image":        noise_image=content_image    elif initial_noise_image=="style_image":        noise_image=style_image    else:        pass#noise_image=noise_image    #optimizer    optimizer = mx.optimizer.Adam(rescale_grad=1.0 , learning_rate=learning_rate)    state = optimizer.create_state(0,noise_image)    #2. learning    for i in tqdm(range(1,epoch+1,1)):        content_loss=nd.array([0,],ctx=ctx)        style_loss=nd.array([0,],ctx=ctx)        # (1) compute content lose        # content : cov4_2        VGG19_content_loss= Get_Content_Loss(content_image=content_image, noise_image=noise_image, image_size=image_size, ctx=ctx)        VGG19_content_loss.forward(is_train=True)        VGG19_content_loss.backward()        optimizer.update(0, noise_image, VGG19_content_loss.grad_arrays, state)        # (2) compute style lose        # style : cov1_1 ,cov2_1 ,cov3_1 ,cov4_1 ,cov5_1        VGG19_style_loss= Get_Style_Loss(style_image=style_image, noise_image=noise_image, image_size=image_size, ctx=ctx)        VGG19_style_loss.forward(is_train=True)        VGG19_style_loss.backward()        optimizer.update(0,noise_image,VGG19_style_loss.grad_arrays,state)        content_loss=0        style_loss=0        loss=nd.add(nd.multiply(content_loss, content_a),nd.multiply(style_loss, style_b))        print(" epoch : {} , cost : {}".format(i, loss.asscalar()))        #saving image        if i%show_period==0:            Artistic_Image(noise_image,image_size)if __name__ == "__main__":    # content_a  / style_b = 1/1000    content_image = "content/tiger.jpg"    style_image = "style/picasso.jpg"    initial_noise_image = "content_image"  # or style image or noise -> Assigning an initial value to the content image is faster than assigning noise.    image_size = (256, 512)  # height , width -> is expected to be at least 224.    NeuralStyle(epoch=1000, show_period=100, learning_rate=0.1, image_size=image_size,                               content_image=content_image, style_image=style_image, content_a=1, style_b=1000,                               initial_noise_image=initial_noise_image, ctx=mx.gpu(0))    print("NeuralStyle in main")else:    print("NeuralStyle imported")